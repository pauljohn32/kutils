#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
%\VignetteIndexEntry{variablekey}

\usepackage{booktabs}
\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

 \centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, %,style=Rstyle}
                        fancyvrb=false,escapechar=`,language=R,%
                        %%basicstyle={\Rcolor\Sweavesize},%
                        backgroundcolor=\Rbackground,%
                        showstringspaces=false,%
                        keywordstyle=\Rcolor,%
                        commentstyle={\Rcommentcolor\ttfamily\itshape},%
                        literate={<<-}{{$\twoheadleftarrow$}}2{~}{{$\sim$}}1{<=}{{$\leq$}}2{>=}{{$\geq$}}2{^}{{$^{\scriptstyle\wedge}$}}1{==}{{=\,=}}1,%
                        alsoother={$},%
                        alsoletter={.<-},%
                        otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
                        escapeinside={(*}{*)}}%


% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.90}}

% for sideways table
\usepackage{rotating}
\end_preamble
\use_default_options true
\begin_modules
sweave
logicalmkup
\end_modules
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Variable Key Data Programming Framework
\end_layout

\begin_layout Author
Paul E.
 Johnson, Benjamin A.
 Kite
\end_layout

\begin_layout Abstract
This essay describes the 
\begin_inset Quotes eld
\end_inset

variable key
\begin_inset Quotes erd
\end_inset

 approach to importing and recoding data.
 This method has been developed in the Center for Research Methods and Data
 Analysis at the University of Kansas to deal with the importation of large,
 complicated data sets.
 This approach improves teamwork, keeps better records, and reduces slippage
 between the intentions of principal investigators the implementation by
 code writers.
 The framework is implemented in the R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"

\end_inset

 package 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{ae=F,nogin=T}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(device = pdf)
\end_layout

\begin_layout Plain Layout

options(width=80, prompt=" ", continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The staff of the Center for Research Methods and Data Analysis has been
 asked to help with data importation and recoding from time to time.
 In one very large project, we were asked to combine, recode, and integrate
 variables from 21 different files.
 The various files used different variable names and had different, unique
 coding schemes.
 A skeptic might have thought that the firm which created the data sets
 intentionally obfuscated the variable names and codings to prevent the
 comparison of variables across a series of surveys.
 
\end_layout

\begin_layout Standard
In projects like that, the challenge of importing and fixing the data seems
 overwhelming.
 The challenge seems overwhelming to the graduate research assistants who
 are asked to cobble together thousands of lines of 
\begin_inset Quotes eld
\end_inset

recodes
\begin_inset Quotes erd
\end_inset

 as they rename, regroup, and otherwise harmonize the information.
 From a managerial point of view, that is not the main problem.
 The time of graduate students is, well, there to be spent.
 While it may be tedious to read a codebook and write recodes, one after
 the other, it is not all that difficult.
 The truly difficult part is mustering up the confidence in the resulting
 recoded data.
 How can a supervisor check thousands of recode statements for accuracy?
 The very extensibility of R itself, its openness to new functions and language
 elements, makes proof-reading more difficult.
 We might shift some of the proof reading duty to the principle investigators,
 but they are sometimes unfamiliar with R (and are not thrilled to wade
 through code).
 The responsibility for verifying the recodes falls on the project supervisors.
 While most supervisors with whom we are personally acquainted have nearly
 super-human reading skills and almost-perfect comprehension, we have documented
 a case in which one of them was unable to catch an error on line 827 within
 an R file with 2119 lines.
 
\end_layout

\begin_layout Standard
To reduce the risk of misunderstanding and error, we propose the 
\emph on
variable key procedure
\emph default
.
 It is a systematic way to separate code writing from the process of renaming
 variables and re-designating their values.
 The characteristics of the data are summarized in a table, a simple-looking
 structure that might be edited in a text editor or a spread sheet program.
 This simple structure, which we call the variable key, can be used by principal
 investigators and supervisors to designate the desired results.
 Once the key is created, then the data set can be imported and recoded
 by the application of the key's information.
 This does not eliminate the need to proof-read the renaming and recoding
 of the variables, it simply shifts that chore into a simpler, more workable
 setting.
\end_layout

\begin_layout Standard
This essay proceeds in 3 parts.
 First, the general concepts behind the variable key system are explored.
 Second, the four stages in the variable key procedure are outlined and
 illustrated with examples.
 Third, we offer some examples of ways to double-check the results.
\end_layout

\begin_layout Section
Enter the Variable Key
\end_layout

\begin_layout Standard
The variable key process was first developed for a very large project for
 which we were hired by a commercial consulting company.
 As it happened, the project manager who hired us was an SPSS user who did
 not know about R, but he was otherwise a very capable person.
 After going through the usual R process of importing and recoding data
 from 6 files, the aggregate of which included more than 40,000 observations
 on 150 variables, we arrived at a renamed set of columns.
 Unfortunately, the research assistant who had done most of the work resigned
 in order to pursue a career as a magician.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or graduated, we are not sure which.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
With the unavailability of our key asset, it was difficult to know for sure
 what was in which column.
 There was nobody to quickly answer 
\begin_inset Quotes eld
\end_inset

sex is V23418, where we changed the 1 to male and 2 to female
\begin_inset Quotes erd
\end_inset

.
 The only way to understand the translation was by hunting and pecking through
 a giant R file.
 
\end_layout

\begin_layout Standard
In order to better understand what had happened, we developed a table that
 looked like Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:A-Small-Variable-key"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A Small Variable Key
\begin_inset CommandInset label
LatexCommand label
name "tab:A-Small-Variable-key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V23419
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

male
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

female
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

neither
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V32422
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
education
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

elem
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

hs
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

somecoll
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

ba
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

post
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V54532
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
income
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numeric
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It was tedious to assemble that table, but it helped quite a bit in our
 discussions.
 The vertical bars were used to indicate that the original data had discrete
 values.
 When a variable has a natural ordering, the new values were placed in order
 with the symbol (
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

).
 That table grew quite large, since it had one row per variable, but it
 was otherwise workable.
 It was popular with the client.
 
\end_layout

\begin_layout Standard
In the middle of preparing that summary table of recoded values, we realized
 that it was possible to write an R program to import the key table and
 use its information to recode and rename the variables.
 The variable key table was not just a 
\begin_inset Quotes eld
\end_inset

codebook.
\begin_inset Quotes erd
\end_inset

 It was a programmable codebook.
 We wrote some functions that could import variables (as named in column
 1), apply the new values (from columns 3 and 4), then apply the new name
 from column 2.
 The functions to do that are, of course, somewhat difficult to prepare,
 but, from a supervisor's point of view, they are very appealing.
 There will be less proof-reading to do, at least in the R code itself.
 Once we can validate the functions, then we never have proof-read them
 again.
 These functions can be applied, row by row, to create a new data frame.
 Instead, we need to concentrate our attention on the substance of the problem,
 the specification of the new names and values in the table.
\end_layout

\begin_layout Standard
In the projects where we have employed this system, we adjusted the key
 and the R functions to suit the particular demands of the project and the
 client.
 That was unfortunate, because we had very little accumulation of code from
 one project to another.
 However, we did accumulate experience; there were concepts and vocabulary
 which allowed us to understand the various challenges that might be faced.
 The effort to develop a standardized framework for the variable key began
 in 2016 with the creation of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

 package for R.
\end_layout

\begin_layout Standard
So far, then, we have outlined a transition process in which project supervisors
 create a table that instructs the research assistants in the importation
 of data.
 There is still a daunting problem, however, because the supervisors must
 create that variable key table itself.
 In a large data set, it might be arduous to simply type the old names of
 the variables and their observed values.
 In 2015 one of the graduate assistants in our lab was asked to type up
 a variable key and he couldn't quite believe that was a good use of his
 time.
 After some discussion
\begin_inset Foot
status open

\begin_layout Plain Layout
violent argument
\end_layout

\end_inset

, we realized that it was not necessary to type the variable key at all.
 Instead of typing this table into a spreadsheet, we decided to make the
 work lighter by using R to write a first draft of the variable key.
 If R can import the candidate data set, then R can certainly output its
 column names and a roster of observed values.
 A function was created to scan a data frame and write a template for the
 key.
 This lightened the workload considerably.
 By tabulating all of the observed variables and their values, the most
 tedious part of the process was done mechanically.
 
\end_layout

\begin_layout Section
Four Simple Steps
\end_layout

\begin_layout Standard
Suppose a 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 data frame has been imported.
 The variable key process has four steps.
 First, create a key template file summarizing the existing state of the
 variables.
 Second, edit the key template file in a spreadsheet or other program that
 can work with comma separate variables.
 Change the names, values, and designate other recodes (which we will describe
 next).
 Third, import the revised key into R.
 Fourth, run a function that generates a new, improved data frame by applying
 the imported key to the data frame.
\end_layout

\begin_layout Standard
If all goes well, we should end up with a new data frame in which
\end_layout

\begin_layout Enumerate
The columns are renamed in accordance with the instructions of the principal
 investigator (or supervisor).
\end_layout

\begin_layout Enumerate
The values of all variables have been recoded according to the instructions
 of the principal investigator (or supervisor).
\end_layout

\begin_layout Standard
Diagnostic tables are reported to clearly demonstrate the effect of each
 coding change, mapping out the difference between the input and the output
 variables.
 
\end_layout

\begin_layout Standard
For testing purposes, we have created an example data frame with seven variables
 of various types.
 The data frame mydf has most of the challenges that we see in actual projects.
 It has integer variables that need to be reorganized and turned into character
 or factor variables.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=T,include=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(234234)
\end_layout

\begin_layout Plain Layout

N <- 200
\end_layout

\begin_layout Plain Layout

mydf <- data.frame(x5 = rnorm(N),
\end_layout

\begin_layout Plain Layout

                   x4 = rpois(N, lambda = 3),
\end_layout

\begin_layout Plain Layout

                   x3 = ordered(sample(c("lo", "med", "hi"),
\end_layout

\begin_layout Plain Layout

                                       size = N, replace=TRUE),
\end_layout

\begin_layout Plain Layout

                                levels = c("med", "lo", "hi")),
\end_layout

\begin_layout Plain Layout

                   x2 = letters[sample(c(1:4,6), 200, replace = TRUE)],
\end_layout

\begin_layout Plain Layout

                   x1 = factor(sample(c("cindy", "jan", "marcia"), 200,
\end_layout

\begin_layout Plain Layout

                        	          replace = TRUE)),
\end_layout

\begin_layout Plain Layout

                   x7 = ordered(letters[sample(c(1:4,6), 200, replace =
 TRUE)]),
\end_layout

\begin_layout Plain Layout

                   x6 = sample(c(1:5), 200, replace = TRUE),
\end_layout

\begin_layout Plain Layout

                   stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

mydf$x4[sample(1:N, 10)] <- 999
\end_layout

\begin_layout Plain Layout

mydf$x5[sample(1:N, 10)] <- -999
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

rockchalk::summarize(mydf, alphaSort = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Step 1.
 keyTemplate
\end_layout

\begin_layout Standard
In 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

, we offer a function called 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 that can scan a data frame and generate a new key template.
 The new template will have the old column names and observed values and
 it will leave place holders for new names and values.
 The function will handle the work of creating the key template object in
 the R workspace or writing it into a file in CSV, XLSX, or RDS format.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 function has an argument named 
\begin_inset Quotes eld
\end_inset

long
\begin_inset Quotes erd
\end_inset

, which can be set as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TRUE
\end_layout

\end_inset

 or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FALSE
\end_layout

\end_inset

.
 If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FALSE
\end_layout

\end_inset

, the key template will be in the format we call 
\begin_inset Quotes eld
\end_inset

wide
\begin_inset Quotes erd
\end_inset

, while if it is true, the result will be a 
\begin_inset Quotes eld
\end_inset

long
\begin_inset Quotes erd
\end_inset

 key.
 The difference between these two things is most apparent if we begin with
 the example 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The key template file that is demonstrated in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Wide-Key"

\end_inset

 is the type we call a 
\emph on
wide
\emph default
 key.
 It is a wide key in the sense that there is one row per variable, and the
 old/new value information is tightly packed into a pair of columns.
 The key includes more or less obvious columns for the old and new variable
 names, their classes, and values of the variables.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wide Key
\begin_inset CommandInset label
LatexCommand label
name "tab:Wide-Key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{lllllllll}
\end_layout

\begin_layout Plain Layout

  
\backslash
toprule
\end_layout

\begin_layout Plain Layout

name
\backslash
_old & name
\backslash
_new & class
\backslash
_old & class
\backslash
_new & value
\backslash
_old & value
\backslash
_new 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
midrule
\end_layout

\begin_layout Plain Layout

x5 & x5 & numeric & numeric &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x4 & x4 & numeric & numeric &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & med$<$lo$<$hi & med$<$lo$<$hi 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & a$|$b$|$c$|$d$|$f & a$|$b$|$c$|$d$|$f
  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x1 & x1 & factor & factor & cindy$|$jan$|$marcia & marcia$|$marcia$|$marcia
 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & a$<$b$<$c$<$d$<$f & a$<$b$<$c$<$d$<$f  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 1$|$2$|$3$|$4$|$5 & 1$|$2$|$3$|$4$|$5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The wide style key was the first type that we developed.
 We have more experience with it.
 However, sometimes there is trouble with the wide key, mostly due to the
 fact that some spread sheet programs do not handle character strings in
 the way that we have come to expect.
 There are practical issues as well, because editing an elaborate string
 within a cell may be inconvenient and frustrating in some programs.
\begin_inset Foot
status open

\begin_layout Plain Layout
If users could be persuaded to edit the key template as a CSV file in an
 high quality text editor, such as Emacs, this would not be problem.
\end_layout

\end_inset

 Using some spread sheet programs, some researchers have had difficulty
 with very wide columns.
 Since the value_old and value_new columns must match exactly, there is
 an element of human error in play.
 At the expense of making a key that has many more rows, we obtain clarity
 by asking instead for a long key template.
 The long key includes one row per value per variable, as illustrated in
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Long-Key"

\end_inset

.
 We assert that the long key template is nearly foolproof.
 It is simple to match the old and new values with one another because there
 is only one value per cell.
 In a project with hundreds of variables, the key may be thousands of lines
 long.
 That is an unfortunate fact of life, but we suggest it is much more easily
 revised and proof-read than the R code that one usually sees in recoding
 exercises.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Key Template, Long Type
\begin_inset CommandInset label
LatexCommand label
name "tab:Long-Key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{llllllll}
\end_layout

\begin_layout Plain Layout

  
\backslash
toprule
\end_layout

\begin_layout Plain Layout

name
\backslash
_old & name
\backslash
_new & class
\backslash
_old & class
\backslash
_new & value
\backslash
_old & value
\backslash
_new & missings & recodes 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
midrule
\end_layout

\begin_layout Plain Layout

x5 & x5 & numeric & numeric &  &  &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x4 & x4 & numeric & numeric &  &  &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & med & med &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & lo & lo &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & hi & hi &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & a & a &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & b & b &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & c & c &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & d & d &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x2 & x2 & character & character & f & f &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x1 & x1 & factor & factor & cindy & marcia &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x1 & x1 & factor & factor & jan & marcia &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x1 & x1 & factor & factor & marcia & marcia &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & a & a &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & b & b &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & c & c &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & d & d &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x7 & x7 & ordered & ordered & f & f &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 1 & 1 &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 2 & 2 &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 3 & 3 &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 4 & 4 &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 5 & 5 &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
bottomrule
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is a major difference in the treatment of continuous and discrete
 variables.
 As readers will note in the example key templates, the information for
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
values_old
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
values_new
\end_layout

\end_inset

 is much more elaborate for discrete variables.
 When a variable has a floating point value in R, that is, as numeric and
 not an integer, then it does not make sense to tabulate individual values.
 A numeric variable may need to be recoded, say by the elimination of missing
 values or by the application of a transformation (logarithm, etc).
 But we should not want to, and cannot reliably, map individual floating
 point values to newly designated variables.
 
\end_layout

\begin_layout Standard
On the other hand, for many discrete variables (factors, characters, integers),
 we do want to freely reassign and regroup the observed values.
 However, it is not certain that the variable key should include all of
 the observed values for every discrete variable.
 In the 
\begin_inset Quotes eld
\end_inset

raw
\begin_inset Quotes erd
\end_inset

 data sets, integers and characters are used in various ways.
 Sometimes the integers represent discrete levels (1 = 
\begin_inset Quotes eld
\end_inset

male
\begin_inset Quotes erd
\end_inset

, 2 = 
\begin_inset Quotes eld
\end_inset

female
\begin_inset Quotes erd
\end_inset

), while sometimes integers represent age or dollar values that we would
 not individually re-assign one-at-a-time.
 In the first case (integers are a substitute for labels), we want the key
 to include all of the observed values so that we can relabel, while in
 the other case we do not.
 The same difference is found in character variables.
 A column coded as 
\begin_inset Quotes eld
\end_inset

male
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

female
\begin_inset Quotes erd
\end_inset

 falls into a different frame of mind than a character variable which represents
 a survey respondent's name or ID number.
 We want the key to include all of the values of the former type of character,
 but it probably should not enumerate all of values of the other type.
 
\end_layout

\begin_layout Standard
There is no fool-proof way to separate the two types of discretely scored
 variables.
 The number of different observed values is not certain to differentiate
 these different types of variables, but we allow it to serve as a guide.
 The same strategy is used in the R foreign packages to import data from
 SPSS.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 function has an argument, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
max.levels
\end_layout

\end_inset

, which places an upper limit on the allowed number of categories.
 If the number of discrete values exceeds 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
max.levels
\end_layout

\end_inset

, then the values of that will no longer be treated as a discrete variable
 at all, since we do not intend to recode individual values with the variable
 key.
 As it does for floating-point variables, the key template (whether wide
 or long) will include only one row for discrete variables with more than
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
max.levels
\end_layout

\end_inset

 observed values.
 The user can adjust max.levels in various ways, as explained in the documentatio
n.
\end_layout

\begin_layout Standard
TODO: Go back to source code and embellish max.levels to treat characters,
 integers as described here.
 Now I believe it is printing 
\begin_inset Quotes eld
\end_inset

max.levels
\begin_inset Quotes erd
\end_inset

 values, but should not.
\end_layout

\begin_layout Standard
Despite the possibility that a factor (or ordered) variable may have many
 values, we believe that all of the levels of those variables should be
 included in the key.
 
\end_layout

\begin_layout Subsection
Step 2.
 Edit the variable key
\end_layout

\begin_layout Standard
The variable key that is generated by 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 should, without editing, be sufficient to re-import the data and reproduce
 exactly the same information.
 As a result, it is not necessary to make extensive changes.
 The supervisor and principal investigator can change just a few variable
 names or values.
 In a large project, there may be quite a bit of work involved.
 
\end_layout

\begin_layout Standard
Over time, our strategy for naming elements in the key has evolved, as has
 the notation for specifying changes.
 At the current time, we believe that the column names in the key should
 include the suffixes 
\begin_inset Quotes eld
\end_inset

_new
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

_old
\begin_inset Quotes erd
\end_inset

 to make the meaning perfectly obvious.
 The verbose variable value style that we illustrate here works dependably,
 while the some abbreviated methods will work.
 
\end_layout

\begin_layout Subsubsection
Factor, ordered, and character variables
\end_layout

\begin_layout Standard
The recoding of discrete variables is a fairly obvious chore.
 For each old value, a new value may be specified.
 
\end_layout

\begin_layout Standard
In the case of character variable input, we allow for various output possibiliti
es.
 The value of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
class_new
\end_layout

\end_inset

 will probably be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
character
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
factor
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ordered
\end_layout

\end_inset

, or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
integer
\end_layout

\end_inset

.
 It is necessary to match up the old values and new values, of course, but
 there is nothing complicated about it.
 In the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

 variable key, we have variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x2
\end_layout

\end_inset

 which is coded 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
a
\end_layout

\end_inset

 through 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
f
\end_layout

\end_inset

.
 Examples of key elements that might change that into a new character, factor,
 or integer variable are illustrated in the following.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excellent|Proficient|Adequate|Marginal|Inadequate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
factor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excellent|Proficient|Adequate|Marginal|Inadequate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4|3|2|1|0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
In line one of this example, the class of the variable remains the same.
 It produces a new character variable with embellished values.
 If we want this to become an R factor variable, line two demonstrates how
 to change the key class_new value.
 It is also possible to convert the character input into integer values,
 as we see in line 3.
\end_layout

\begin_layout Standard

\series bold
TODO question: could we allow the key to specify multiple recodings for
 a variable, one to create character, one to create factor, etc? I'm not
 sure it is designed to do that now.
\end_layout

\begin_layout Standard
Similarly, it is obvious to see how an integer input can be converted into
 either an integer, character, or factor variable by employing any of these
 rows in the new key.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100|200|300|400|500
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Austin|Denver|Nashville|Provo|Marcia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
factor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F|D|C|B|A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
If a variable's class_old is ordered, and we simply want to relabel the
 existing levels, the work is also easy.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F<D<C<B<A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fail<Fail<Pass<Pass<Pass
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0|1|2|3|4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The second row in this example shows that factor levels can be 
\begin_inset Quotes eld
\end_inset

combined
\begin_inset Quotes erd
\end_inset

 by assigning the same character string to several 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 separated values.
 
\end_layout

\begin_layout Standard
Working with ordered variables, whether as input or output, becomes more
 complicated if the existing data is not ordered in the way we want.
 In the toy data example, the variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf$x3
\end_layout

\end_inset

 was coded as an ordered variable with levels (
\begin_inset Quotes eld
\end_inset

med
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

lo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

).
 That might have been one person's idea of a joke, so we need to rearrange
 these as (
\begin_inset Quotes eld
\end_inset

lo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

med
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

).
 If the original ordering of the values is not consistent with the desired
 ordering of the new ordered factor, then we need notation that allows researche
rs to achieve two purposes.
 First, the values must be re-leveled.
 Second, allow for the possibility that the new values must be relabeled
 as well.
 We'd rather not proliferate new columns in the variable key or create some
 confusing new notation.
\end_layout

\begin_layout Standard
Reordering variable levels requires us to do something that seems dangerous.
 We need to edit the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 to correct the ordering of the levels 
\emph on
as they are currently labeled
\emph default
.
 This is the only time where we suggest that users edit the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 column.
 In 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

, supply new labels in the in the correct order to parallel the newly edited
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 column.
 For example,
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<med<hi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<medium<high
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<med<hi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<pass<pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The key importer will check that all 
\begin_inset Quotes eld
\end_inset

duplicated levels
\begin_inset Quotes erd
\end_inset

 are adjacent with one another, so that the values above low are grouped
 together.
\end_layout

\begin_layout Standard
In the long key format, the equivalent information would be conveyed by
 altering the ordering of the rows.
 For example, it is necessary to re-order the rows to indicate the lo is
 lower than med, and then for the new values we put in the desired names.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{llllllll}
\end_layout

\begin_layout Plain Layout


\backslash
toprule
\end_layout

\begin_layout Plain Layout

name
\backslash
_old & name
\backslash
_new & class
\backslash
_old & class
\backslash
_new & value
\backslash
_old & value
\backslash
_new & missings & recodes 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
midrule
\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & lo & low &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & med & medium &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3 & ordered & ordered & hi & high &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
bottomrule
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our first efforts, we tried to stick to the principle that the observed
 scores in the value_old column should not be altered and we should concentrate
 our effort on setting the corresponding value_new.
 However, that makes it difficult to reorder the levels of a factor, which
 can be especially important for ordered variables.
\end_layout

\begin_layout Standard
In addition, the R symbol for missing values, NA, can be used in place of
 any new value to indicate that cases with a particular score should be
 treated as missing.
 Sometimes there is confusion when data is passed in and out of CSV or XLSX
 format, because a character variable might have a legal value 
\begin_inset Quotes eld
\end_inset

NA
\begin_inset Quotes erd
\end_inset

 and it may also be necessary to assign the R missing value of NA.
 
\end_layout

\begin_layout Standard
TODO: fix this, describe the output key 
\begin_inset Quotes eld
\end_inset

mydf.key.csv
\begin_inset Quotes erd
\end_inset

 and get EXCEL discussion on how to add quoted elements inside strings.
 Need to write out what Excel does to a string like 
\begin_inset Quotes eld
\end_inset

cindy|bobby|
\begin_inset Quotes erd
\end_inset

NA
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

, figure out why the key currently exports one big string 
\begin_inset Quotes eld
\end_inset

bobby|cindy|marcia
\begin_inset Quotes erd
\end_inset

 when perhaps instead it should export 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

bobby
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

cindy
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

marcia
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsubsection
About numeric variables
\end_layout

\begin_layout Standard
In the process that creates the variable key template, we attempt to separate
 the variables with meaningfully discrete values--ones that we recode by
 reassignment of one-by-one values--from numeric variables that we think
 of differently.
 The non-discrete variables are included as one row in a variable key (whether
 wide or long) and the main elements of interest for these variables are
 the columns labeled 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
missings
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The key specification of missing values for various types of variables is
 spelled out in detail for the help page of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
assignMissing
\end_layout

\end_inset

 function in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 For numeric variables, there are only three types of statements allowed
 in the recode column.
 Legal values must must begin with the characters 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

.
 The first two indicate that observed scores less than, or greater than,
 the value which follows are treated as missing.
 The symbols 
\begin_inset Quotes eld
\end_inset

<=
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

>=
\begin_inset Quotes erd
\end_inset

 are accepted in the obvious way.
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
recodes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
interpretation: NA will be assigned to 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values greater than t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> 99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>= t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values greater than or equal to t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>=99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values less than t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values less than or equal to t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c(a,b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values equal to or greater than a and less than or equal to b 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c(-999,0)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Class concerns
\end_layout

\begin_layout Standard
Two elements in this key that we have not already mentioned are the columns
 named class_old and class_new.
 These were introduced to facilitate two chores.
 First, we might edit the values of the class_old variable, and then use
 those classes to re-import the data and reassign the variables in a desired
 way.
 Another scenario might be that a client provides a new data frame which
 is allegedly equivalent to a previous set.
 The values in class_old and value_old might give us a first step to verifying
 their claim that the new data is actually equivalent.
 Second, the class_new column allows us to indicate, for example, that a
 variable currently coded as 1 for males and 2 for female should become
 an R factor variable with an indicated set of levels.
\end_layout

\begin_layout Standard
As described in the R help page for the function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
as.numeric
\end_layout

\end_inset

, there are some confusing aspects in the treatment of integers and floating
 point values in R.
 The R function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is.numeric
\end_layout

\end_inset

 will return TRUE if the variable under consideration is an integer or a
 floating point variable, although as.numeric returns a floating-point (double)
 variable.
 It is possible for users to declare variables as integers, however, and
 so the two types of numeric variables are not necessarily indistinguishable.
 To disambiguate, the keyTemplate function marks class_old for a known integer
 variable as 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

, while the more ambiguous class_old value 
\begin_inset Quotes eld
\end_inset

numeric
\begin_inset Quotes erd
\end_inset

 is used for variables that are truly double-precision floating point numbers
 or integer variables that have not were not declared as integers when the
 data was imported.
\end_layout

\begin_layout Subsection
Step 3.
 keyImport
\end_layout

\begin_layout Standard
Once any desired changes to variables have been entered into the variable
 key, the file needs to be imported back into R.
 First, the csv (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
read.csv
\end_layout

\end_inset

), xlsx (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
openxlsx::read.xlsx
\end_layout

\end_inset

), or rds (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
readRDS
\end_layout

\end_inset

) file containing the edited key needs to be read into R.
 It is important to specify 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
stringsAsFactor = FALSE
\end_layout

\end_inset

 as an argument when reading the key into R.
 Next the key is provided to the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function is set to read short keys by default, providing the argument 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
long = TRUE
\end_layout

\end_inset

 will switch to a long key.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function always returns a list with information about how each variable
 is to be recoded.
 The structure of the list will be the same with a long or short key being
 provided.
 Inspecting the key list will show that each item contains the information
 provided in a single row of a short key.
 The key list has a fixed format so that the process of using the key list
 to manipulate the data is not influenced by what key format was used.
 We do not suggest attempting to create a key list manually.
 See the example below taken from the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 documentation.
 
\end_layout

\begin_layout Standard
TAKE A DAY AND THINK ABOUT HOW TO MAKE A BETTER EXAMPLE AND COVER ALL RELEVANT
 DETAILS HERE.
 
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mydf.key <- read.csv(mydf.key.path, stringsAsFactor = FALSE) 
\end_layout

\begin_layout Plain Layout

mydf.keylist2 <- keyImport(mydf.key, long = FALSE)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Step 4.
 Apply the imported key to the data
\end_layout

\begin_layout Standard
The final step is to apply the key to the data frame that needs variables
 recoded.
 The recoded data frame is obtained by assigning a name to the output of
 the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

 function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyApply
\end_layout

\end_inset

.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyApply
\end_layout

\end_inset

 function takes the name of the data frame to be recoded and the key list
 created in Step 3 to produce a new data frame with the desired recodings.
 
\end_layout

\begin_layout Standard
TAKE A DAY AND THINK ABOUT HOW TO BEST INCLUDE AN EXAMPLE HERE.
 
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
When a project has a small budget, we invite the principal investigator
 to economize on the expenses by filling out the variable key's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
name_new
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
class_new
\end_layout

\end_inset

, and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

 columns.
 There are several benefits in inviting the clients (or PIs) to be directly
 involved in filling in the variable key.
 Most importantly, they are allowed to name the variables in any way that
 is meaningful to them.
 When statistical results are obtained, it is never necessary for them to
 ask, 
\begin_inset Quotes eld
\end_inset

what did you mean by this variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
occupation
\end_layout

\end_inset

?
\begin_inset Quotes erd
\end_inset

 There are other benefits, however.
 By making the principal investigator aware of the values that are actually
 observed, and by offering the opportunity to specify how they ought to
 be recoded, a substantial element of administrative slippage is ameliorated.
 The variable key will specify exactly how categories are to be re-mapped,
 there is much less danger of an accident buried in thousands of lines of
 recodes.
\end_layout

\begin_layout Standard
It often happens that the raw data to be imported is provided by one of
 the national data centers.
 The variables are given exciting, meaningful column names like V34342a.
 It appears to be almost certain that research assistants will conclude
 that these names are not meaningful, so they create names that are more
 meaningful to them, such as 
\emph on
gender
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
male
\emph default
, 
\emph on
female
\emph default
, or whatnot.
 The research assistants disappear into a haze of code and come out talking
 about the effect of income, gender, and education on educational achievement,
 and the principal investigator has to say, 
\begin_inset Quotes eld
\end_inset

which of those variables is income, again?
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

what's the coding on education?
\begin_inset Quotes erd
\end_inset

 A very exciting conversation then follows as one of the research assistant
 realizes that V34342b is the one that should have been used for gender,
 while V34342a indicates if the respondent ever visited Eastern Europe.
\end_layout

\begin_layout Standard
Although some bright people don't know R, it appears they are all fluent
 in spread sheet.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Variable Key Editing Guidelines
\end_layout

\begin_layout Enumerate
Omit a variable: delete its row(s) from the (long)key.
\end_layout

\begin_layout Enumerate
Manage data importation.
\end_layout

\begin_deeper
\begin_layout Enumerate
Need importation check for column classes and possible coercion.
 But...
\end_layout

\begin_layout Enumerate
What to do about mismatch between column classes in imported data frame
 and the class_old in the key? This will happen if read.csv is used to import
 data, since it does not have colClasses=
\begin_inset Quotes erd
\end_inset

ordinal
\begin_inset Quotes erd
\end_inset

 as a possible.
 Also 
\begin_inset Quotes eld
\end_inset

numeric
\begin_inset Quotes erd
\end_inset

 is confusing.
 If the key's old_value is, for example, 
\begin_inset Quotes eld
\end_inset

ordinal
\begin_inset Quotes erd
\end_inset

, and read.csv has been used to import the data (without specifying stringsAsFact
ors = FALSE), then it might be suitable to coerce.
 But if stringsAsFactors = FALSE, 
\end_layout

\end_deeper
\begin_layout Enumerate
Assign missings:
\end_layout

\begin_deeper
\begin_layout Enumerate
discrete variables: several options, we should settle on one suggestion
\end_layout

\begin_deeper
\begin_layout Enumerate
insert 
\begin_inset Quotes eld
\end_inset

NA
\begin_inset Quotes erd
\end_inset

 in value_new column
\end_layout

\begin_layout Enumerate
delete the value_old entry (not the best way, maybe don't mention it)
\end_layout

\begin_layout Enumerate
list a vector of missing values in the recode column.
 This vector applies to data as it was imported, before applying the value_old
 to value_new transition.
 PROBLEM: if input data's class does not match class_old, there may be a
 problem.
\end_layout

\end_deeper
\begin_layout Enumerate
numeric variables
\end_layout

\end_deeper
\begin_layout Plain Layout
2.
\end_layout

\begin_layout Plain Layout
3.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "kutils"
options "chicago"

\end_inset


\end_layout

\end_body
\end_document
