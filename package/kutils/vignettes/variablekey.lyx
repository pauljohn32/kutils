#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
%\VignetteIndexEntry{variablekey}

\usepackage{booktabs}
\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

 \centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, %,style=Rstyle}
                        fancyvrb=false,escapechar=`,language=R,%
                        %%basicstyle={\Rcolor\Sweavesize},%
                        backgroundcolor=\Rbackground,%
                        showstringspaces=false,%
                        keywordstyle=\Rcolor,%
                        commentstyle={\Rcommentcolor\ttfamily\itshape},%
                        literate={<<-}{{$\twoheadleftarrow$}}2{~}{{$\sim$}}1{<=}{{$\leq$}}2{>=}{{$\geq$}}2{^}{{$^{\scriptstyle\wedge}$}}1{==}{{=\,=}}1,%
                        alsoother={$},%
                        alsoletter={.<-},%
                        otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
                        escapeinside={(*}{*)}}%


% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.95}}

% for sideways table
\usepackage{rotating}
\end_preamble
\use_default_options true
\begin_modules
sweave
logicalmkup
\end_modules
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Variable Key Data Programming Framework
\end_layout

\begin_layout Author
Paul E.
 Johnson and Benjamin A.
 Kite
\end_layout

\begin_layout Abstract
This essay describes the 
\begin_inset Quotes eld
\end_inset

variable key
\begin_inset Quotes erd
\end_inset

 approach to importing and recoding data.
 This method has been developed in the Center for Research Methods and Data
 Analysis at the University of Kansas to deal with the importation of large,
 complicated data sets.
 This approach improves teamwork, keeps better records, and reduces slippage
 between the intentions of principal investigators the implementation by
 code writers.
 The framework is implemented in the R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"

\end_inset

 package 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F>>=
\end_layout

\begin_layout Plain Layout

if(!dir.exists("plots")) dir.create("plots")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=plots/t,split=T,ae=F,height=4,width=5.5}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(device = pdf)
\end_layout

\begin_layout Plain Layout

options(width=100, prompt=" ", continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(ps=10)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The staff of the Center for Research Methods and Data Analysis has been
 asked to help with data importation and recoding from time to time.
 In one very large project, we were asked to combine, recode, and integrate
 variables from 21 different files.
 The various files used different variable names and had different, unique
 coding schemes.
 A skeptic might have thought that the firm which created the data sets
 intentionally obfuscated the records to prevent the comparison of variables
 across a series of surveys.
 
\end_layout

\begin_layout Standard
In projects like that, the challenge of importing and fixing the data seems
 overwhelming.
 The graduate research assistants are asked to cobble together thousands
 of lines of 
\begin_inset Quotes eld
\end_inset

recodes
\begin_inset Quotes erd
\end_inset

 as they rename, regroup, and otherwise harmonize the information.
 From a managerial point of view, that is not the main problem.
 We expect to spend the time of research assistants.
 While it may be tedious to read a codebook and write recodes, social scientists
 have been doing that since the 1960s.
 It is not all that difficult.
 The truly difficult part is mustering up the confidence in the resulting
 recoded data.
 How can a supervisor check thousands of recode statements for accuracy?
 The very extensibility of R itself–its openness to new functions and language
 elements–makes proof-reading more difficult.
 We might shift some of the proof reading duty to the principle investigators,
 but they sometimes not interested in details.
 In the end, the responsibility for verifying the recodes falls on the project
 supervisors.
 While most supervisors with whom we are personally acquainted have nearly
 super-human reading skills and almost-perfect comprehension, we have documented
 a case in which one of them was unable to catch an error on line 827 within
 an R file with 2119 lines.
 
\end_layout

\begin_layout Standard
To reduce the risk of misunderstanding and error, we propose the 
\emph on
variable key procedure
\emph default
.
 It is a systematic way to separate code writing from the process of renaming
 variables and re-designating their values.
 The characteristics of the data are summarized in a table, a simple-looking
 structure that might be edited in a text editor or a spread sheet program.
 This simple structure, which we call the variable key, can be used by principal
 investigators and supervisors to designate the desired results.
 Once the key is created, then the data set can be imported and recoded
 by the application of the key's information.
 This does not eliminate the need to proof-read the renaming and recoding
 of the variables, it simply shifts that chore into a simpler, more workable
 setting.
\end_layout

\begin_layout Standard
This essay proceeds in 3 parts.
 First, the general concepts behind the variable key system are explored.
 Second, the four stages in the variable key procedure are outlined and
 illustrated with examples.
 Third, we offer some examples of ways to double-check the results.
\end_layout

\begin_layout Section
Enter the Variable Key
\end_layout

\begin_layout Standard
The variable key process was first developed for a very large project for
 which we were hired by a commercial consulting company.
 As it happened, the project manager who hired us was an Excel user who
 did not know about R.
 He was given several SPSS datasets.
 After going through the usual R process of importing and recoding data
 from 6 files, the aggregate of which included more than 40,000 observations
 on 150 variables, we arrived at a renamed set of columns.
 Unfortunately, the research assistant who had done most of the work resigned
 in order to pursue a career as a magician.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or graduated, we are not sure which.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
With the unavailability of our key asset, it was difficult to know for sure
 what was in which column.
 There was nobody to quickly answer questions like 
\begin_inset Quotes eld
\end_inset

which column is the respondent's sexual identity?
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

if sex is V23418, did we change 1 to male or female
\begin_inset Quotes erd
\end_inset

.
 The only way to find out is by hunting and pecking through a giant R file.
 
\end_layout

\begin_layout Standard
In order to better communicate about that project, we developed a table
 that looked like Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:A-Small-Variable-key"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A Small Variable Key
\begin_inset CommandInset label
LatexCommand label
name "tab:A-Small-Variable-key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V23419
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sex
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

male
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

female
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

neither
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V32422
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
education
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

elem
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

hs
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

somecoll
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

ba
\begin_inset Quotes erd
\end_inset

<
\begin_inset Quotes erd
\end_inset

post
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V54532
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
income
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numeric
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It was tedious to assemble that table, but it helped quite a bit in our
 discussions.
 The vertical bars were used to indicate that the original data had discrete
 values.
 When a variable has a natural ordering, the new values were placed in order
 with the symbol (
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

).
 That table grew quite large, since it had one row per variable, but it
 was otherwise workable.
 It was popular with the client.
 
\end_layout

\begin_layout Standard
In the middle of preparing that summary table of recoded values, we realized
 that it was possible to write an R program to import the key table and
 use its information to recode and rename the variables.
 The recodes would 
\emph on
just happen
\emph default
.
 If we prepared the functions properly, we had not just a table masquerading
 as a codebook, we had a 
\emph on
programmable codebook
\emph default
.
 We wrote some functions that could import variables (as named in column
 1), apply the new values (from columns 3 and 4), then apply the new name
 from column 2.
 The functions to do that are, of course, somewhat difficult to prepare,
 but, from a supervisor's point of view, they are very appealing.
 There will be less proof-reading to do, at least in the R code itself.
 Once we can validate the functions, then we never have proof-read them
 again.
 These functions can be applied, row by row, to create a new data frame.
 Instead, we need to concentrate our attention on the substance of the problem,
 the specification of the new names and values in the table.
\end_layout

\begin_layout Standard
In the projects where we have employed this system, we adjusted the key
 and the R functions to suit the particular demands of the project and the
 client.
 That was unfortunate, because we had very little accumulation of code from
 one project to another.
 However, we did accumulate experience; there were concepts and vocabulary
 which allowed us to understand the various challenges that might be faced.
 The effort to develop a standardized framework for the variable key began
 in 2016 with the creation of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

 package for R.
\end_layout

\begin_layout Standard
The variable key process allows project supervisors to create a table that
 instructs the research assistants in the importation, renaming, and recoding
 of data.
 There is still a daunting problem, however, because the supervisors must
 create that variable key table.
 In a large data set, it might be arduous to simply type the old names of
 the variables and their observed values.
 In 2015 one of the graduate assistants in our lab was asked to type up
 a variable key and he couldn't quite believe that was a good use of his
 time.
 After some discussion, we realized that it was not necessary to type the
 variable key at all.
 We would write a function to do so.
 If R can import the candidate data set, then R can certainly output its
 column names and a roster of observed values.
 This lightened the workload considerably.
 By tabulating all of the observed variables and their values, the most
 tedious part of the process was done mechanically.
 
\end_layout

\begin_layout Standard
In the remainder of this essay, we discuss the process of creating a variable
 key template, revising it, and putting it to use.
 
\end_layout

\begin_layout Section
Four Simple Steps
\end_layout

\begin_layout Standard
The variable key process has four steps.
 First, inspect an R data.frame object and create a key template file.
 The key template summarizes the existing state of the variables and creates
 
\begin_inset Quotes eld
\end_inset

placeholders
\begin_inset Quotes erd
\end_inset

 where we might like to specify revisions.
 Second, edit the key template file in a spreadsheet or other program that
 can work with comma separate variables.
 Change the names, values, and designate other recodes (which we will describe
 next).
 Third, import the revised key into R.
 Fourth, apply the key to the data to generate a new, improved data frame.
 Then run some diagnostic routines.
\end_layout

\begin_layout Standard
If all goes well, we should end up with a new data frame in which
\end_layout

\begin_layout Enumerate
The columns are renamed in accordance with the instructions of the principal
 investigator (or supervisor).
\end_layout

\begin_layout Enumerate
The values of all variables have been recoded according to the instructions
 of the principal investigator (or supervisor).
\end_layout

\begin_layout Standard
Diagnostic tables are reported to clearly demonstrate the effect of each
 coding change, mapping out the difference between the input and the output
 variables.
 
\end_layout

\begin_layout Standard
For purposes of illustration, we have create an example data frame with
 various types of variables.
 This data frame, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

, has most of the challenges that we see in actual projects.
 It has integer variables that need to be reorganized and turned into character
 or factor variables.
 It has character variables that might become integers or factors.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=T,include=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(234234)
\end_layout

\begin_layout Plain Layout

N <- 200
\end_layout

\begin_layout Plain Layout

mydf <- data.frame(
\end_layout

\begin_layout Plain Layout

    x5 = rnorm(N),
\end_layout

\begin_layout Plain Layout

    x4 = rpois(N, lambda = 3),
\end_layout

\begin_layout Plain Layout

    x3 = ordered(sample(c("lo", "med", "hi"), size = N, replace=TRUE),
\end_layout

\begin_layout Plain Layout

            levels = c("med", "lo", "hi")),
\end_layout

\begin_layout Plain Layout

    x2 = letters[sample(c(1:4,6), 200, replace = TRUE)],
\end_layout

\begin_layout Plain Layout

    x1 = factor(sample(c("cindy", "jan", "marcia"), 200,
\end_layout

\begin_layout Plain Layout

            replace = TRUE)),
\end_layout

\begin_layout Plain Layout

    x7 = ordered(letters[sample(c(1:4,6), 200, replace = TRUE)]),
\end_layout

\begin_layout Plain Layout

    x6 = sample(c(1:5), 200, replace = TRUE),
\end_layout

\begin_layout Plain Layout

            stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

mydf$x4[sample(1:N, 10)] <- 999
\end_layout

\begin_layout Plain Layout

mydf$x5[sample(1:N, 10)] <- -999
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Step 1.
 Create a Key Template
\end_layout

\begin_layout Standard
In 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

, we offer a function called 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 that can scan a data frame and generate a new key template.
 The new template will have the old column names and observed values and
 it will leave place holders for new names and values.
 At the current time, there are two formats for the key template, 
\begin_inset Quotes eld
\end_inset

long
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

wide
\begin_inset Quotes erd
\end_inset

.
 Both of these are equally useful, they simply organize the information
 differently.
 
\end_layout

\begin_layout Standard
Code like this
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

key <- keyTemplate(mydf, file = "key_wide.csv")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
will produce a 
\begin_inset Quotes eld
\end_inset

wide
\begin_inset Quotes erd
\end_inset

 key because that is the default.
 The key will be saved in a comma-separated variable file.
 
\end_layout

\begin_layout Standard
If the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
file
\end_layout

\end_inset

 argument is included, the suffix servers as a signal of the desired file
 type.
 At the current time, we allow for file names ending in 
\begin_inset Quotes eld
\end_inset

.csv
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.xlsx
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

.rds
\begin_inset Quotes erd
\end_inset

.
 These create comma separated variable files, Excel spreadsheets, and R
 serialization data structures.
 It is certainly allowed to save the key object in other file types, but
 then the duty of re-importing the key information after editing falls on
 the user.
 This will be discussed in the third step below.
\end_layout

\begin_layout Standard
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 function's argument 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
long
\end_layout

\end_inset

 can be set as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
TRUE
\end_layout

\end_inset

 or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FALSE
\end_layout

\end_inset

.
 If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
FALSE
\end_layout

\end_inset

, the key template will be in the wide.
 The essence of the difference is that the wide format puts all of the required
 information into a one-row-per-variable format, while the long version
 creates one-row-per-value.
 The difference is most apparent if we begin with the example 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A LaTeX rendition of the data.frame object that holds a wide key template
 is demonstrated in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:The-Wide-Key"

\end_inset

.
 It is called a wide key because the recoding information is tightly packed
 into 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

.
 The key includes more or less obvious columns for the old and new variable
 names, their classes, and values of the variables.
 That key results from the following code.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key0, include=F>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

library(xtable)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key10>>=
\end_layout

\begin_layout Plain Layout

keywide <- keyTemplate(mydf, long = FALSE, max.levels = 5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
max.levels
\end_layout

\end_inset

 parameter defaults to 15, so that an integer variable with less than 15
 values will have each value displayed.
 The display of that variable key was too wide for the page in this essay,
 so we reduced the number of values.
 When the observed number of scores is above 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
max.levels
\end_layout

\end_inset

, the key does not try to list the individual values (compare the treatment
 of variables 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
x4
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\noindent
x6
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
A long key template is displayed in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Long-Key"

\end_inset

.
 That key is produced as follows.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key30>>=
\end_layout

\begin_layout Plain Layout

keylong <- keyTemplate(mydf, long = TRUE, max.levels = 5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Wide Key Template
\begin_inset CommandInset label
LatexCommand label
name "tab:The-Wide-Key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Sweavesize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout

<<key20,echo=FALSE,results=tex>>=
\end_layout

\begin_layout Plain Layout

print(xtable(keywide), include.rownames = FALSE, size = "small", floating
 = FALSE )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Long Key Template
\begin_inset CommandInset label
LatexCommand label
name "tab:Long-Key"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Sweavesize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout

<<key40,echo=FALSE,results=tex>>=
\end_layout

\begin_layout Plain Layout

print(xtable(keylong), include.rownames = FALSE, size = "small", floating
 = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is necessary to treat categorical and numeric data differently.
 If a column includes floating point numbers (temperatures, dollar values,
 etc), then we would not plan for a research mission that wants to recode
 individual values one-by-one.
 However, if a column includes integers, then the project may intend to
 treat them as discrete values (1 = male, 2 = female).
 They may also be numeric, however, and we don't expect to recode individual
 values (age, IQ score).
 A numeric variable may need to be recoded, say by the elimination of missing
 values or by the application of a transformation (logarithm, etc).
 We handle those recodes from a different point of view, with the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
missings
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

 columns in the variable key.
 
\end_layout

\begin_layout Standard
The information for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
values_old
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
values_new
\end_layout

\end_inset

 is much more elaborate for discrete variables.
 For discrete variables (factors, characters, integers), researchers do
 want to freely reassign and regroup the observed values.
 If the observed number of unique scores is smaller than max.levels, then
 the key will enumerate them.
 If more values are observed, the key will not enumerate them.
 If a researchers feels this is incorrect, then the key can be edited to
 enumerate and change the values (see below).
\end_layout

\begin_layout Standard
The same issue arises with character variables.
 A column coded as 
\begin_inset Quotes eld
\end_inset

male
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

female
\begin_inset Quotes erd
\end_inset

 falls into a different frame of mind than a character variable which represents
 a survey respondent's name or ID number.
 We want the key to include all of the values of the former type of character,
 but it probably should not enumerate all of values of the other type.
 The max.levels parameter is just a way of guessing how many unique levels
 is 
\begin_inset Quotes eld
\end_inset

too many
\begin_inset Quotes erd
\end_inset

 for an enumeration.
\end_layout

\begin_layout Standard
Despite the possibility that a factor (or ordered) variable may have many
 values, we believe that all of the levels of those variables should be
 usually be included in the key.
 If a variable is declared as a factor, it means the researcher has assigned
 meaning to the various observed values and we are reluctant to ignore them.
\end_layout

\begin_layout Standard
Some users have asked 
\begin_inset Quotes eld
\end_inset

should we use the wide key or the long key?
\begin_inset Quotes erd
\end_inset

 This is simply a matter of taste.
 In a project that has variables with many unique observed values, the wide
 format may become hard to manage.
 The long format eliminates any ambiguity about the old value and the new
 value.
 The disadvantage of the long format is that it is somewhat verbose, with
 repeated values in the name and class values.
\end_layout

\begin_layout Subsection
Step 2.
 Edit the variable key
\end_layout

\begin_layout Standard
The variable key that is generated by 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplate
\end_layout

\end_inset

 should, without editing, be sufficient to re-import the data and reproduce
 exactly the same data frame.
 As a result, it is not necessary to make extensive changes in a key.
 One may simply intend to rename all of the columns, for example, by editing
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
name_new
\end_layout

\end_inset

.
 The supervisor and principal investigator can change just a few variable
 names or values.
 In a large project, there may be quite a bit of work involved.
 
\end_layout

\begin_layout Standard
Because editing the key can be a rather involved process, we will wait to
 discuss the details until section 
\end_layout

\begin_layout Subsection
Step 3.
 keyImport
\end_layout

\begin_layout Standard
Once any desired changes to variables have been entered into the variable
 key, the file needs to be imported back into R.
 First, the csv (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
read.csv
\end_layout

\end_inset

), xlsx (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
openxlsx::read.xlsx
\end_layout

\end_inset

), or rds (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
readRDS
\end_layout

\end_inset

) file containing the edited key needs to be read into R.
 It is important to specify 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
stringsAsFactor = FALSE
\end_layout

\end_inset

 as an argument when reading the key into R.
 Next the key is provided to the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function is set to read short keys by default, providing the argument 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
long = TRUE
\end_layout

\end_inset

 will switch to a long key.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

 function always returns a list with information about how each variable
 is to be recoded.
 The structure of the list will be the same with a long or short key being
 provided.
 Inspecting the key list will show that each item contains the information
 provided in a single row of a short key.
 The key list has a fixed format so that the process of using the key list
 to manipulate the data is not influenced by what key format was used.
 We do not suggest attempting to create a key list manually.
 See the code below for a basic example of how a key file is read into R
 and then provided to 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mydf.key <- read.csv("mydf.key.csv", stringsAsFactor = FALSE) 
\end_layout

\begin_layout Plain Layout

mydf.keylist <- keyImport(mydf.key, long = FALSE)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Step 4.
 Apply the imported key to the data
\end_layout

\begin_layout Standard
The final step is to apply the key to the data frame that needs variables
 recoded.
 The recoded data frame is obtained by assigning a name to the output of
 the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

 function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyApply
\end_layout

\end_inset

.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyApply
\end_layout

\end_inset

 function takes the name of the data frame to be recoded and the key list
 created in Step 3 to produce a new data frame with the desired recodings.
 See the code below for a basic example of how an imported key is applied
 to a data frame.
 
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

keyed.df <- keyApply(mydf, mydf.keylist)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Editing the variable key
\begin_inset CommandInset label
LatexCommand label
name "sec:Editing-the-key"

\end_inset


\end_layout

\begin_layout Subsection
Factor, ordered, and character variables
\end_layout

\begin_layout Standard
The recoding of discrete variables is a fairly obvious chore.
 For each old value, a new value may be specified.
 
\end_layout

\begin_layout Standard
In the case of character variable input, we allow for various output possibiliti
es.
 The value of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
class_new
\end_layout

\end_inset

 will be 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
character
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
factor
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ordered
\end_layout

\end_inset

, or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
integer
\end_layout

\end_inset

.
 It is necessary to match up the old values and new values, of course, but
 there is nothing complicated about it.
 In the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

 variable key, we have variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x2
\end_layout

\end_inset

 which is coded 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
a
\end_layout

\end_inset

 through 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
f
\end_layout

\end_inset

.
 Examples of key elements that might change that into a new character, factor,
 or integer variable are illustrated in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Change-Type-Example1"

\end_inset

.
 Here we show the middle section of the revised key in which we have spawned
 3 new variants of x2, each with its own name
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Change Class, Example 1
\begin_inset CommandInset label
LatexCommand label
name "tab:Change-Type-Example1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x2.char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excellent|Proficient|Good|Fair|Poor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x2.fac
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
factor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excellent|Proficient|Good|Fair|Poor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x2.gpa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a|b|c|d|f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4|3|2|1|0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In line one of Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Change-Type-Example1"

\end_inset

, the class 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
character
\end_layout

\end_inset

 remains the same.
 That line will produce a new character variable with embellished values.
 Line two demonstrates how to create an R factor variable.
 We change the class_new to factor.
 It is also possible to convert the character input into integer values,
 as we see in line 3.
\end_layout

\begin_layout Standard
Similarly, it is obvious to see how an integer input can be converted into
 either an integer, character, or factor variable by employing any of the
 rows seen in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Change-Type-Example2"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Change Class Example 2
\begin_inset CommandInset label
LatexCommand label
name "tab:Change-Type-Example2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.i100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100|200|300|400|500
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Austin|Denver|Nashville|Provo|Miami
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x6.f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
factor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1|2|3|4|5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F|D|C|B|A
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If a variable's class_old is ordered, and we simply want to relabel the
 existing levels, the work is also easy (see Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Change-Type-Example3"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Change Class, Example 3
\begin_inset CommandInset label
LatexCommand label
name "tab:Change-Type-Example3"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
name_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x7.grades
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F<D<C<B<A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x7.passfail
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fail<Fail<Pass<Pass<Pass
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x7.gpa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f<d<c<b<a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0|1|2|3|4
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The second row in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Change-Type-Example3"

\end_inset

 shows that factor levels can be 
\begin_inset Quotes eld
\end_inset

combined
\begin_inset Quotes erd
\end_inset

 by assigning the same character string to several 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

 separated values.
 
\end_layout

\begin_layout Standard
Working with ordered variables, whether as input or output, becomes more
 complicated if the existing data is not ordered in the way we want.
 In the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf
\end_layout

\end_inset

 example, the variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mydf$x3
\end_layout

\end_inset

 was coded as an ordered variable with levels (
\begin_inset Quotes eld
\end_inset

med
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

lo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

).
 That might have been one person's idea of a joke, so we need to rearrange
 these as (
\begin_inset Quotes eld
\end_inset

lo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

med
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

).
 If the original ordering of the values is not consistent with the desired
 ordering of the new ordered factor, then we need notation that allows researche
rs to achieve two purposes.
 First, the values must be re-leveled.
 Second, allow for the possibility that the new values must be relabeled
 as well.
 We'd rather not proliferate new columns in the variable key or create some
 confusing new notation.
\end_layout

\begin_layout Standard
Reordering variable levels requires us to do something that seems dangerous.
 We need to edit the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 to correct the ordering of the levels 
\emph on
as they are currently labeled
\emph default
.
 This is the only time where we suggest that users edit the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 column.
 In 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

, supply new labels in the in the correct order to parallel the newly edited
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 column (see Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Reorder-Values"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reorder Values, Example 1
\begin_inset CommandInset label
LatexCommand label
name "tab:Reorder-Values"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
class_new
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_old
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
value_new
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x3.lo2hi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<med<hi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<medium<high
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x3.passfail
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ordered
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<med<hi
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
low<pass<pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The key importer will check that all 
\begin_inset Quotes eld
\end_inset

duplicated levels
\begin_inset Quotes erd
\end_inset

 are adjacent with one another, so that the values above low are grouped
 together.
\end_layout

\begin_layout Standard
In the long key format, the equivalent information would be conveyed by
 altering the ordering of the rows.
 For example, it is necessary to re-order the rows to indicate the lo is
 lower than med, and then for the new values we put in the desired names
 (see Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Reorder-Values-Example2"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reorder Values, Example 2
\begin_inset CommandInset label
LatexCommand label
name "tab:Reorder-Values-Example2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{llllllll}
\end_layout

\begin_layout Plain Layout


\backslash
toprule
\end_layout

\begin_layout Plain Layout

name
\backslash
_old & name
\backslash
_new & class
\backslash
_old & class
\backslash
_new & value
\backslash
_old & value
\backslash
_new & missings & recodes 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
midrule
\end_layout

\begin_layout Plain Layout

x3 & x3lo2hi & ordered & ordered & lo & low &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3lo2hi & ordered & ordered & med & medium &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3lo2hi & ordered & ordered & hi & high &  &  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3.passfail & ordered & ordered & low & low & & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3.passfail & ordered & ordered & medium & pass & & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x3 & x3.passfail & ordered & ordered & high & pass & & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
bottomrule
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The R symbol for missing values, NA, can be used in place of any new value
 to indicate that cases with a particular score should be treated as missing.
 Sometimes there is confusion when data is passed in and out of CSV or XLSX
 format, because a character variable might have a legal value 
\begin_inset Quotes eld
\end_inset

NA
\begin_inset Quotes erd
\end_inset

 and it may also be necessary to assign the R missing value of NA.
 
\end_layout

\begin_layout Standard
TODO: fix this, describe the output key 
\begin_inset Quotes eld
\end_inset

mydf.key.csv
\begin_inset Quotes erd
\end_inset

 and get EXCEL discussion on how to add quoted elements inside strings.
 Need to write out what Excel does to a string like 
\begin_inset Quotes eld
\end_inset

cindy|bobby|
\begin_inset Quotes erd
\end_inset

NA
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

, figure out why the key currently exports one big string 
\begin_inset Quotes eld
\end_inset

bobby|cindy|marcia
\begin_inset Quotes erd
\end_inset

 when perhaps instead it should export 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

bobby
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

cindy
\begin_inset Quotes erd
\end_inset

|
\begin_inset Quotes erd
\end_inset

marcia
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsubsection
About numeric variables
\end_layout

\begin_layout Standard
In the process that creates the variable key template, we attempt to separate
 the variables with meaningfully discrete values–ones that we recode by
 reassignment of one-by-one values–from numeric variables that we think
 of differently.
 The non-discrete variables are included as one row in a variable key (whether
 wide or long) and the main elements of interest for these variables are
 the columns labeled 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
missings
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The key specification of missing values for various types of variables is
 spelled out in detail for the help page of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
assignMissing
\end_layout

\end_inset

 function in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 For numeric variables, there are only three types of statements allowed
 in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
missings
\end_layout

\end_inset

 column.
 Legal values must must begin with the characters 
\begin_inset Quotes eld
\end_inset

<
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

>
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

.
 The first two indicate that observed scores less than, or greater than,
 the value which follows are treated as missing.
 The symbols 
\begin_inset Quotes eld
\end_inset

<=
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

>=
\begin_inset Quotes erd
\end_inset

 are accepted in the obvious way.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Recode-Examples"

\end_inset

 for examples of possible 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
missings
\end_layout

\end_inset

 input.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Missings Examples
\begin_inset CommandInset label
LatexCommand label
name "tab:Recode-Examples"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
missings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
interpretation: NA will be assigned to 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
example
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values greater than t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> 99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>= t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values greater than or equal to t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>=99
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values less than t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values less than or equal to t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c(a,b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values equal to or greater than a and less than or equal to b 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c(-999,0)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The key specification for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

 is discussed in the help page of the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
assignRecode
\end_layout

\end_inset

 function in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
 The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

 column takes R code and applies it to the desired variable.
 For example, if one wanted to transform a variable by taking its square
 root, this could be done by providing 
\begin_inset Quotes eld
\end_inset

sqrt(x)
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
recodes
\end_layout

\end_inset

 column.
 Here 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 is simply a placeholder where the name of the variable indicated in the
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
name_new
\end_layout

\end_inset

 column will be inserted when the variable key is applied.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Recoding Integer and Numeric Variables
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
footnotesize
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{lllllllll}
\end_layout

\begin_layout Plain Layout

  
\backslash
toprule
\end_layout

\begin_layout Plain Layout

name
\backslash
_old & name
\backslash
_new & class
\backslash
_old & class
\backslash
_new & value
\backslash
_old & value
\backslash
_new & missings & recodes 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

  
\backslash
midrule
\end_layout

\begin_layout Plain Layout

x5 & x5 & numeric & numeric &  &  & <0 & log(x) 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x4 & x4 & numeric & numeric &  &  & c(-999) & abs(x) 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

x6 & x6 & integer & integer & 1$|$2$|$3$|$4$|$5 & 1$|$2$|$3$|$4$|$5 & c(-9)
 & 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

   
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Class concerns
\end_layout

\begin_layout Standard
Two elements in this key that we have not already mentioned are the columns
 named class_old and class_new.
 These were introduced to facilitate two chores.
 First, we might edit the values of the class_old variable, and then use
 those classes to re-import the data and reassign the variables in a desired
 way.
 Another scenario might be that a client provides a new data frame which
 is allegedly equivalent to a previous set.
 The values in class_old and value_old might give us a first step to verifying
 their claim that the new data is actually equivalent.
 Second, the class_new column allows us to indicate, for example, that a
 variable currently coded as 1 for males and 2 for female should become
 an R factor variable with an indicated set of levels.
\end_layout

\begin_layout Standard
As described in the R help page for the function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
as.numeric
\end_layout

\end_inset

, there are some confusing aspects in the treatment of integers and floating
 point values in R.
 The R function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is.numeric
\end_layout

\end_inset

 will return TRUE if the variable under consideration is an integer or a
 floating point variable, although as.numeric returns a floating-point (double)
 variable.
 It is possible for users to declare variables as integers, however, and
 so the two types of numeric variables are not necessarily indistinguishable.
 To disambiguate, the keyTemplate function marks class_old for a known integer
 variable as 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

, while the more ambiguous class_old value 
\begin_inset Quotes eld
\end_inset

numeric
\begin_inset Quotes erd
\end_inset

 is used for variables that are truly double-precision floating point numbers
 or integer variables that have not were not declared as integers when the
 data was imported.
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
When a project has a small budget, we invite the principal investigator
 to economize on the expenses by filling out the variable key's 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
name_new
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
class_new
\end_layout

\end_inset

, and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

 columns.
 There are several benefits in inviting the clients (or PIs) to be directly
 involved in filling in the variable key.
 Most importantly, they are allowed to name the variables in any way that
 is meaningful to them.
 When statistical results are obtained, it is never necessary for them to
 ask, 
\begin_inset Quotes eld
\end_inset

what did you mean by this variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
occupation
\end_layout

\end_inset

?
\begin_inset Quotes erd
\end_inset

 There are other benefits, however.
 By making the principal investigator aware of the values that are actually
 observed, and by offering the opportunity to specify how they ought to
 be recoded, a substantial element of administrative slippage is ameliorated.
 The variable key will specify exactly how categories are to be re-mapped,
 there is much less danger of an accident buried in thousands of lines of
 recodes.
\end_layout

\begin_layout Standard
It often happens that the raw data to be imported is provided by one of
 the national data centers.
 The variables are given exciting, meaningful column names like V34342a.
 It appears to be almost certain that research assistants will conclude
 that these names are not meaningful, so they create names that are more
 meaningful to them, such as 
\emph on
gender
\emph default
, 
\emph on
sex
\emph default
, 
\emph on
male
\emph default
, 
\emph on
female
\emph default
, or whatnot.
 The research assistants disappear into a haze of code and come out talking
 about the effect of income, gender, and education on educational achievement,
 and the principal investigator has to say, 
\begin_inset Quotes eld
\end_inset

which of those variables is income, again?
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

what's the coding on education?
\begin_inset Quotes erd
\end_inset

 A very exciting conversation then follows as one of the research assistant
 realizes that V34342b is the one that should have been used for gender,
 while V34342a indicates if the respondent ever visited Eastern Europe.
\end_layout

\begin_layout Standard
Although some bright people don't know R, it appears they are all fluent
 in spread sheet.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
Variable Key Editing Guidelines
\end_layout

\begin_layout Enumerate
Omit a variable: delete its row(s) from the (long)key.
\end_layout

\begin_layout Enumerate
The 
\begin_inset Quotes eld
\end_inset

class_new
\begin_inset Quotes erd
\end_inset

 value must be one of the following
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
discrete variable types:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
integer
\end_layout

\begin_layout Description
factor
\end_layout

\begin_layout Description
ordered
\end_layout

\begin_layout Description
logical
\end_layout

\begin_layout Description
character
\end_layout

\begin_layout Description
Date
\end_layout

\end_deeper
\begin_layout Enumerate
floating-point numeric variable types:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
numeric
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Creating new variables.
 Each input variable may be recoded in several different ways, assigning
 a name_new value unique for each.
 
\end_layout

\begin_layout Enumerate
Assigning new values.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
discrete variable types.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
New 
\begin_inset Quotes eld
\end_inset

value_old
\begin_inset Quotes erd
\end_inset

 elements can be inserted in anticipation of new data sets with previously
 unobserved values.
\end_layout

\begin_layout Enumerate
To assign new values to any of the discrete variable types, set values in
 
\begin_inset Quotes eld
\end_inset

value_new
\begin_inset Quotes erd
\end_inset

.
 It is important that the values can be coerced by R to match the value
 of 
\begin_inset Quotes eld
\end_inset

class_new
\begin_inset Quotes erd
\end_inset

.
 That is to say, if 
\begin_inset Quotes eld
\end_inset

class_new
\begin_inset Quotes erd
\end_inset

 is a 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

, then 
\begin_inset Quotes eld
\end_inset

value_new
\begin_inset Quotes erd
\end_inset

 should be an integer.
\end_layout

\end_deeper
\begin_layout Enumerate
numeric variable types.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Because floating point numbers do not allow comparison with 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

, it is not allowed to use 
\begin_inset Quotes eld
\end_inset

value_old
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

value_new
\begin_inset Quotes erd
\end_inset

 pairs for these variables.
 It is necessary to write statements in the recode column of the variable
 key.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Assign missings:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
discrete variables: several options, we should settle on one suggestion
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
insert 
\begin_inset Quotes eld
\end_inset

NA
\begin_inset Quotes erd
\end_inset

 in value_new column
\end_layout

\begin_layout Enumerate
delete the value_old entry (not the best way, maybe don't mention it)
\end_layout

\begin_layout Enumerate
list a vector of missing values in the recode column.
 This vector applies to data as it was imported, before applying the value_old
 to value_new transition.
 PROBLEM: if input data's class does not match class_old, there may be a
 problem.
\end_layout

\end_deeper
\begin_layout Enumerate
numeric variables
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "kutils"
options "chicago"

\end_inset


\end_layout

\end_body
\end_document
